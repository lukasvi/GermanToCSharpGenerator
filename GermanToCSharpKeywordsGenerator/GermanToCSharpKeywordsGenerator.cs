using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GermanToCSharpKeywordsGenerator;

/// <summary>
/// A source generator that converts fake C# with german keywords in the source code to their corresponding C# keywords.
/// This generator processes files with a ".dcs" extension and rewrites the code to match C# syntax.
/// As Intelli-Sense does not support ".dcs" files, it also performs some checks on the file to ensure correct
/// class names, namespaces and class declarations to aid implementation.
/// </summary>
[Generator]
public class GermanToCSharpKeywordsGenerator : ISourceGenerator
{
    private static readonly string _prefix = 
        $"// This class is auto-generated by {nameof(GermanToCSharpKeywordsGenerator)}\r\n" +
        $"// {DateTime.Now:yyyy-MM-dd HH:mm:ss}\r\n" +
        $"// <auto-generated />\r\n\r\n";

    private static readonly DiagnosticDescriptor GeneralErrorDescriptor = new(
        id: "GEN001",
        title: "General Source Generator Execution Error",
        messageFormat: "An error occurred during source generator execution: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor ClassNotFoundErrorDescriptor = new(
        id: "GEN002",
        title: "Source Generator Execution Error: Class not found",
        messageFormat: "The classname was not found in file: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor NamespaceNotFoundErrorDescriptor = new(
        id: "GEN003",
        title: "Source Generator Execution Error: Namespace not found",
        messageFormat: "No namespace was found in file: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor MultipleClassesErrorDescriptor = new(
        id: "GEN004",
        title: "Source Generator Execution Warning: Multiple classes found",
        messageFormat: "More than one class was found in file: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor ClassNameMismatchErrorDescriptor = new(
        id: "GEN005",
        title: "Source Generator Execution Warning: Class name does not match file name",
        messageFormat: "The class name '{0}' does not match the file name '{1}'",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true
    );

    ///<inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        // Activate this if needed for debugging
#if DEBUG
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
#endif
    }

    ///<inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            foreach (var file in context.AdditionalFiles)
            {
                if (!file.Path.EndsWith(".dcs"))
                {
                    continue;
                }

                var sourceCode = file.GetText()?.ToString();
                if (string.IsNullOrWhiteSpace(sourceCode))
                {
                    continue;
                }

                var newSource = GermanToEnglishRewriter.ConvertGermanToEnglish(sourceCode!);

                var tree = CSharpSyntaxTree.ParseText(newSource);
                var root = tree.GetRoot();

                var classDeclarations = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();

                if (classDeclarations.Count == 0)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        ClassNotFoundErrorDescriptor,
                        Location.Create(file.Path, new TextSpan(0, 0), new LinePositionSpan(new LinePosition(0, 0), new LinePosition(0, 0))),
                        file.Path
                    ));
                    continue;
                }

                if (classDeclarations.Count > 1)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        descriptor: MultipleClassesErrorDescriptor,
                        location: classDeclarations[0].GetLocation(),
                        additionalLocations: classDeclarations.Skip(1).Select(x => x.GetLocation()),
                        file.Path
                    ));
                }

                var expectedClassName = Path.GetFileNameWithoutExtension(file.Path);
                var classDeclaration = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();
                if (!classDeclaration.Identifier.Text.Equals(expectedClassName, StringComparison.OrdinalIgnoreCase))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        ClassNameMismatchErrorDescriptor,
                        classDeclaration.Identifier.GetLocation(),
                        classDeclaration.Identifier.Text, expectedClassName
                    ));
                }

                var namespaceDeclaration = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>().FirstOrDefault();

                var fileScopednamespaceDeclaration = root.DescendantNodes().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();


                if (namespaceDeclaration == null && fileScopednamespaceDeclaration == null)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        NamespaceNotFoundErrorDescriptor,
                        Location.Create(file.Path, new TextSpan(), new LinePositionSpan()),
                        file.Path
                    ));
                    continue;
                }

                var filename = Path.GetFileNameWithoutExtension(file.Path);
                context.AddSource($"{filename}.g.cs", SourceText.From(_prefix + newSource, Encoding.UTF8));
            }
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(GeneralErrorDescriptor, Location.None, ex.Message));
        }
    }
}
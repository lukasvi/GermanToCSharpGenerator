using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GermanToCSharpKeywordsGenerator;

[Generator]
public class GermanToCSharpKeywordsGenerator : ISourceGenerator
{
    private static readonly Dictionary<string, string> _germanToEnglishKeywords = new()
    {
        { "öffentlich", "public" },
        { "privat", "private" },
        { "geschützt", "protected" },
        { "intern", "internal" },
        { "statisch", "static" },
        { "abstrakt", "abstract" },
        { "versiegelt", "sealed" },
        { "neu", "new" },
        { "virtuell", "virtual" },
        { "überschreibt", "override" },
        { "asynchron", "async" },
        { "aufgabe", "Task" },
        { "erwarte", "await" },
        { "Klasse", "class" },
        { "Schnittstelle", "interface" },
        { "Struktur", "struct" },
        { "Aufzählung", "enum" },
        { "Delegat", "delegate" },
        { "Zeichenkette", "string" },
        { "GanzeZahl", "int" },
        { "Gleitkommazahl", "float" },
        { "Doppel", "double" },
        { "Boolean", "bool" },
        { "Leere", "void" },
        { "Zeichen", "char" },
        { "Lang", "long" },
        { "Kurz", "short" },
        { "Byte", "byte" },
        { "Zeiger", "pointer" },
        { "Konstante", "const" },
        { "nurlesend", "readonly" },
        { "variiere", "var" },
        { "dynamisch", "dynamic" },
        { "dies", "this" },
        { "Basis", "base" },
        { "zurückkehren", "return" },
        { "wenn", "if" },
        { "sonst", "else" },
        { "wechseln", "switch" },
        { "fall", "case" },
        { "Standard", "default" },
        { "während", "while" },
        { "für", "for" },
        { "jede", "foreach" },
        { "tu", "do" },
        { "unterbrechen", "break" },
        { "fortfahren", "continue" },
        { "probieren", "try" },
        { "fangen", "catch" },
        { "werfen", "throw" },
        { "endlich", "finally" },
        { "BenutzerdefinierterTyp", "typeof" },
        { "GrößeVon", "sizeof" },
        { "überprüft", "checked" },
        { "ungeprüft", "unchecked" },
        { "explizit", "explicit" },
        { "implizit", "implicit" },
        { "ist", "is" },
        { "als", "as" },
        { "verwendet", "using" },
        { "Namenraum", "namespace" },
        { "teilweise", "partial" },
        { "außerhalb", "extern" },
        { "ÜbergabeVerweis", "ref" },
        { "heraus", "out" },
        { "innen", "in" },
        { "Ertrag", "yield" },
        { "erweitert", "extension" },
        { "abfragen", "query" },
        { "LinQ", "LINQ" },
        { "Gruppe", "group" },
        { "beitreten", "join" },
        { "wo", "where" },
        { "auswählen", "select" },
        { "Auftrag", "order" },
        { "von", "from" },
        { "lassen", "let" },
        { "gleich", "equals" },
        { "steigt", "ascending" },
        { "absteigend", "descending" },
        { "global", "global" },
        { "ThreadStatisch", "ThreadStatic" },
        { "Konsole", "Console" },
        { "Schreiber", "Writer" },
        { "Leser", "Reader" },
        { "Variable", "var" },
        { "SchreibeLinie", "WriteLine" }
    };

    private static readonly string _prefix = 
        $"// This class is auto-generated by {nameof(GermanToCSharpKeywordsGenerator)}\r\n" +
        $"// {DateTime.Now:yyyy-MM-dd HH:mm:ss}\r\n" +
        $"// <auto-generated />\r\n\r\n";

    private static readonly DiagnosticDescriptor GeneralErrorDescriptor = new(
        id: "GEN001",
        title: "General Source Generator Execution Error",
        messageFormat: "An error occurred during source generator execution: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );


    private static readonly DiagnosticDescriptor ClassNotFoundErrorDescriptor = new(
        id: "GEN002",
        title: "Source Generator Execution Error: Class not found",
        messageFormat: "The classname was not found in file: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor NamespaceNotFoundErrorDescriptor = new(
        id: "GEN003",
        title: "Source Generator Execution Error: Namespace not found",
        messageFormat: "No namespace was found in file: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor MultipleClassesErrorDescriptor = new(
        id: "GEN004",
        title: "Source Generator Execution Warning: Multiple classes found",
        messageFormat: "More than one class was found in file: {0}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true
    );

    public void Initialize(GeneratorInitializationContext context)
    {
        // No need for explicit additional file registration

#if DEBUG
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
#endif
    }

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            foreach (var file in context.AdditionalFiles)
            {
                if (!file.Path.EndsWith(".dcs"))
                    continue;

                var sourceCode = file.GetText()?.ToString();
                if (string.IsNullOrWhiteSpace(sourceCode)) continue;

                string newSource = sourceCode!;

                foreach (var keyValuePair in _germanToEnglishKeywords)
                {
                    var german = keyValuePair.Key;
                    var english = keyValuePair.Value;

                    newSource = newSource.Replace(german, english);
                }

                var tree = CSharpSyntaxTree.ParseText(newSource);
                var root = tree.GetRoot();
                var classDeclarations = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();

                if (classDeclarations.Count == 0)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        ClassNotFoundErrorDescriptor,
                        Location.Create(file.Path, new TextSpan(0, 0), new LinePositionSpan(new LinePosition(0, 0), new LinePosition(0, 0))),
                        file.Path
                    ));
                    continue;
                }

                if (classDeclarations.Count > 1)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        descriptor: MultipleClassesErrorDescriptor,
                        location: classDeclarations[0].GetLocation(),
                        additionalLocations: classDeclarations.Skip(1).Select(x => x.GetLocation()),
                        file.Path
                    ));
                }

                var namespaceDeclaration = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>().FirstOrDefault();

                var fileScopednamespaceDeclaration = root.DescendantNodes().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();


                if (namespaceDeclaration == null && fileScopednamespaceDeclaration == null)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        NamespaceNotFoundErrorDescriptor,
                        Location.Create(file.Path, new TextSpan(), new LinePositionSpan()),
                        file.Path
                    ));
                    continue;
                }

                var filename = Path.GetFileNameWithoutExtension(file.Path);
                context.AddSource($"{filename}.g.cs", SourceText.From(_prefix + newSource, Encoding.UTF8));
            }
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(GeneralErrorDescriptor, Location.None, ex.Message));
        }
    }
}